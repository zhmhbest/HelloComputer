
```mermaid
graph LR
    style entry fill:LightGray,stroke:Blue;
    style critical fill:OrangeRed,stroke:Blue;
    style exit fill:LightGray,stroke:Blue;
    style remainder fill:LightGray,stroke:Blue;
    entry([进入区])
    -->critical([临界区])
    -->exit([退出区])
    -->remainder([剩余区])
```

**进程互斥**：对**临界资源**的访问，需要互斥进行。即当一个进程进入临界区使用临界资源时，另一个进程必须等待。

**访问临界资源原则**：空闲让进、忙则等待、有限等待、让权等待

**进程同步**：保证各个进程按预期的方式推进。

### 互斥软件实现方法

单标致法、双标志先检查法、双标志后检查法、Peterson算法

```cpp
/**
 * 【单标致法】
 * 说明：每个进程进入临界区的权限只能被另一个进程赋予。
 * 问题：不遵循空闲让进。
 */
int turn = 0;

// P0
while(0 != turn) {  // 进入区
    ...;            // 临界区
    turn = 1;       // 退出区
    ...;            // 剩余区
}

// P1
while(1 != turn) {  // 进入区
    ...;            // 临界区
    turn = 0;       // 退出区
    ...;            // 剩余区
}
```

```cpp
/**
 * 【双标志先检查法】
 * 说明：先检查后上锁，标记每个进程想进入临界区的意愿。
 * 问题：不遵循忙则等待，若按①⑥②⑦③⑧顺序，则两者同时访问临界区。
 */
bool flag[2];
flag[0] = false;
flag[1] = false;

// P0
while(flag[1]) {        // ①进入区，其它进程是否想进入
    flag[0] = true;     // ②进入区，表明自己意愿
    ...;                // ③临界区
    flag[0] = false;    // ④退出区
    ...;                // ⑤剩余区
}

// P1
while(flag[0]) {        // ⑥进入区，其它进程是否想进入
    flag[1] = true;     // ⑦进入区，表明自己意愿
    ...;                // ⑧临界区
    flag[1] = false;    // ⑨退出区
    ...;                // ⑩剩余区
}
```

```cpp
/**
 * 【双标志后检查法】
 * 说明：先上锁后检查。
 * 问题：不遵循空闲让进和有限等待，若按①⑥②⑦顺序，则两者均无法访问临界区。
 */
bool flag[2];
flag[0] = false;
flag[1] = false;

// P0
flag[0] = true;         // ①进入区，表明自己意愿
while(flag[1]) {        // ②进入区，其它进程是否想进入
    ...;                // ③临界区
    flag[0] = false;    // ④退出区
    ...;                // ⑤剩余区
}

// P1
flag[1] = true;         // ⑥进入区，表明自己意愿
while(flag[0]) {        // ⑦进入区，其它进程是否想进入
    ...;                // ⑧临界区
    flag[1] = false;    // ⑨退出区
    ...;                // ⑩剩余区
}
```

```cpp
/**
 * 【Peterson算法】
 * 说明：主动谦让。
 * 问题：不遵循让权等待。
 */
bool flag[2];
flag[0] = false;
flag[1] = false;
int turn = 0;

// P0
flag[0] = true;                 // ①进入区，表明自己意愿
turn = 1                        // ②进入区，主动避让
while(flag[1] && 1 == turn) {   // ③进入区，其它进程是否想进入且当前礼让中
    ...;                        // ④临界区
    flag[0] = false;            // ⑤退出区
    ...;                        // ⑥剩余区
}

// P1
flag[1] = true;                 // ⑦进入区，表明自己意愿
turn = 0                        // ⑧进入区，主动避让
while(flag[0] && 0 == turn) {   // ⑨进入区，其它进程是否想进入且当前礼让中
    ...;                        // ⑩临界区
    flag[1] = false;            // ⑪退出区
    ...;                        // ⑫剩余区
}
```

### 互斥硬件实现方法

|                | 实现方式         | 优点               | 缺点             |
| -------------: | :--------------- | :----------------- | :--------------- |
|   **中断屏蔽** | 开/关中断指令    | 简单高效           | 只适用于单机处理 |
| **TestAndSet** | 记录、上锁、检查 | 实现简单，多机适用 | 不遵循让权等待   |
|       **Swap** | 记录、上锁、检查 | 实现简单，多机适用 | 不遵循让权等待   |

### 信号量机制

>软件和硬件互斥方法存在问题：
>1.检查和上锁操作无法一气呵成。
>2.无法实现让权等待。

**原语**：由**关中断**/**开中断**实现，一旦开始执行，就不能被中断的若干条指令。

**PV操作**：一对原语，`wait(S)`和`signal(S)`简称`P(S)`、`V(S)`。

**整型信号量**：

```cpp
int S = 1;          // 初始化整型信号量

void wait(int S) {
    while(S <= 0);  // 资源不够则等待资源
    S--;
}

void signal(int S) {
    S++;
}
```

```cpp
// P0进程
wait(S);        // 申请资源S
...;            // 使用资源S
signal(S);      // 释放资源S
```

**记录型信号量**：为解决**整型信号量**的**忙等待问题**，即**不满足让权等待**问题。

```cpp
typedef struct {
    int value;          // 可用资源数量
    struct process *L;  // 等待进程队列
} semaphore;

void wait(semaphore S) {
    S.value--;
    if(S < 0) block(S.L);           // RUNNING --> BLOCKED
}

void signal(semaphore S) {
    S.value++;
    if(S.value <= 0) wakeup(S.L)    // BLOCKED --> READY
}
```

```cpp
// P0进程
wait(S);        // 申请资源S
...;            // 使用资源S
signal(S);      // 释放资源S
```

#### 管程

用于解决信号量机制编程复杂的问题，包含共享数据结构、数据结构初始化语句、一组用来访问数据结构的过程。

- 外部进程/线程只能通过管程提供特定入口才能访问共享数据
- 每次仅允许一个进程在管程内执行某个内部过程

<!--问题：生产者消费者问题、吸烟者问题、读者写者问题、哲学家进餐问题 -->
