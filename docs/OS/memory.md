
### 地址转换

- 绝对装入：编译时产生绝对地址
- 可重定位装入：装入时将逻辑地址转换为物理地址
- 动态运行时装入：运行时将逻辑地址转换为物理地址，需设置重定位寄存器

### 内存保护

- 上下限寄存器
- 限长寄存器（届地址寄存器、重定位寄存器）

### 覆盖与交换

- 覆盖技术：按照逻辑，让不能同时被访问的程序段共享同一个覆盖区。
- 交换技术：内存紧张时，将内存中某些进程暂时换出到外存交换区（PCB则常驻内存）。

### 内存分配

|                  | 实现方法                             | 特定                   |
| ---------------: | :----------------------------------- | :--------------------- |
| **单一连续分配** | 分为系统区和用户区                   | 无外部碎片，有内部碎片 |
| **固定分区分配** | 将用户空间划分为若干个固定大小的分区 | 无外部碎片，有内部碎片 |
| **动态分区分配** | 装入时基于程序大小动态创建           | 无内部碎片，有外部碎片 |

#### 动态分区分配

|              | 思想           | 空闲分区             | 开销 | 缺点               |
| -----------: | :------------- | :------------------- | :--: | :----------------- |
| **首次适应** | 从头到尾找最适 | 地址递增             |  小  |                    |
| **最佳适应** | 优先使用小分区 | 容量递增             |  大  | 难以利用碎片多     |
| **最坏适应** | 优先使用大分区 | 容量递减             |  大  | 不易满足大进程需要 |
| **邻近适应** | 从上次结束位置 | 地址递增（循环链表） |  小  | 高地址大分区被使用 |

### 分页存储管理

基本思想：非连续分配，把进程分页，各个页面离散的放到各个内存块中。

物理层面：将内存空间分为多个大小相等（太大可能产生过大的内部碎片）的分区，每个分区就是一个**页框（页帧、内存块、物理块）**，每个页框有一个编号即**页框号（页帧号、内存块号、物理块号）**，页框号从0开始。

逻辑层面：用户进程的地址空间也分为与页框大小相等的一个个区域称为**页（页面）**，每个页有一个**页号**，页号从0开始。

#### 页表

存储了**逻辑页**与**物理块**的对应关系`(页号, 块号)`。

- **页表长度**：**页表**有几个**页表项**。
- **页表项长度**：**页表项**占存储空间大小。
- **页面长度**：**页面**占存储空间大小。

#### 地址转换

- $\textnormal{\footnotesize 页号} = \left\lfloor{\dfrac{\textnormal{\footnotesize 逻辑地址}}{\textnormal{\footnotesize 页面长度}}}\right\rfloor$，并检查页号是否合法
- $\textnormal{\footnotesize 页内偏移量} = \textnormal{\footnotesize 逻辑地址} {\rm \ mod \ } \textnormal{\footnotesize 页面长度}$
- 查询页表（有快表时查快表）：$\textnormal{\footnotesize 页号} \xrightarrow[]{(\textnormal{\footnotesize 页号}, \textnormal{\footnotesize 块号})} \textnormal{\footnotesize 块号}$
- $\textnormal{\footnotesize 起始地址} = \textnormal{\footnotesize 块号} × \textnormal{\footnotesize 块大小}$
- $\textnormal{\footnotesize 物理地址} = \textnormal{\footnotesize 起始地址} + \textnormal{\footnotesize 页内偏移量}$

#### 多级页表

各级页表大小不能超过一个页面大小，使用两级页表（`(一级页号, 二级页号, 页内偏移量)`、`(页号, 块号)`）需要$3$次访存，$N$级页表需要$N+1$次访存。

### 分段存储管理

|            | 分段                 | 分页                       |
| ---------: | :------------------- | :------------------------- |
|       目的 | 系统管理需要         | 更好地满足用户需要         |
| 用户可见性 | 不可见               | 可见                       |
|       大小 | 由系统决定的固定大小 | 取决于用户编译时信息的性质 |
|       维度 | 一维                 | 二维                       |

#### 段表

存储了**逻辑段**与**物理地址**的对应关系`(段号（隐含）, 段长, 基址)`。

### 段页式存储管理

先将程序分为若干段，再将每段分为若干页。逻辑地址结构为用户提供`(段号, 段内地址)`，实际存储`(段号, 页号, 页内偏移量)`。段页式段表为`(段号（隐含）, 页表长度, 页表存放地址)`与分段存储管理中的段表不同。段页式访问一个逻辑地址需要访存$3$次（没有快表时），若快表命中则仅需$1$次访存。

### 虚拟内存

程序不需要全部装入即可允许，运行时根据需要动态调入数据，内存不够时换出一部分数据。

#### 虚拟内存特征

- 多次性
- 对换性
- 虚拟性

#### 局部性原理

- 时间局部性
- 空间局部性
- 高速缓存技术

#### 实现技术

- 虚拟内存实现
  - 请求分页存储管理
    - 页表有所改变为`(页号, 块号, 状态位, 访问字段, 修改位, 外存地址)`
    - 缺页中断为内中断中的故障，属于可以被系统修复的异常
    - 一条执行在执行过程中可能产生多次缺页中断
  - 请求分段存储管理
  - 请求段页式存储管理
- 请求调页功能：访问信息不存在时
- 页面置换功能：内存空间不够时

#### 页面置换算法

|                    | 规则                                                | 评价                                   |
| ------------------ | --------------------------------------------------- | -------------------------------------- |
| OPT                | 优先淘汰最长时间不会被访问的页面                    | 缺页率最小，性能最好，但无法实现       |
| FIFO               | 优先淘汰最先进入内存的页面                          | 实现简单，性能很差，可能出现Belady异常 |
| LRU                | 优先淘汰最近最久没有访问的页面                      | 性能好，算法开销大且需硬件支持         |
| CLOCK（NRU）       | 淘汰第一个访问位为0的，访问后若为1则置为0，最多两轮 | 实现简单，开销小，未考虑页面是否被修改 |

**改进的CLOCK（改进的NRU）算法**：记录`(访问位, 修改位)`，最多进行四轮扫描。

- 第1轮：扫描替换第一个`(0,0)`
- 第1轮：扫描替换第一个`(0,1)`，所有扫描过的`访问位=0`
- 第3轮：扫描替换第一个`(0,0)`
- 第4轮：扫描替换第一个`(0,1)`

#### 页面分配策略

**驻留集**：请求分页存储管理中给进程分配的物理块的集合。

**工作集**：某段时间间隔内，进程实际访问的页面的集合。

**固定分配/可变分配**：运行期间驻留集大小是否可变。

**局部替换/全局替换**：缺页时，是否只能换出进程自己的页面。

**抖动**：刚换入的页面马上又要换出，主要原因是进程频繁访问的页面数目高于可用物理块数，即分配给进程的物理块不够。

- 固定分配局部替换
- 可变分配全局替换：发生缺页就会获得新物理块；内存耗尽时，选择一个未锁定页面调出，该页所属进程缺页率会增加。
- 可变分配局部替换：频繁缺页则适当增加物理块；反之则适当减少物理块。

