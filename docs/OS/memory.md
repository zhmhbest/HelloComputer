
**硬件结构**：寄存器、高速缓存、内存

**内存保护**：上下限寄存器、限长寄存器（届地址寄存器、重定位寄存器）

**覆盖技术**：按照逻辑，让不能同时被访问的程序段共享同一个覆盖区。

**交换技术**：内存紧张时，将内存中某些进程暂时换出到外存交换区（PCB则常驻内存）。

**内存碎片**：不能被使用的内存区域。

### 程序装入方式

|           装入方式 | 可装入内存中不同位置 | 可在内存中移动 | 说明                                                 |
| -----------------: | :------------------: | :------------: | ---------------------------------------------------- |
|       **绝对装入** |          ×           |       ×        | 程序中的逻辑地址即为物理地址                         |
|   **可重定位装入** |          √           |       ×        | 装入时将逻辑地址转换为物理地址                       |
| **动态运行时装入** |          √           |       √        | 运行时将逻辑地址转换为物理地址<br>需设置重定位寄存器 |

### 连续内存分配

|                      | 实现方法                               | 有外部碎片 | 有内部碎片 |
| -------------------: | :------------------------------------- | :--------: | :--------: |
|     **单一连续分配** | 直接分为**系统区**和**用户区**         |     ×      |     √      |
|     **固定分区分配** | **用户区**分为固定大小的多个子分区     |     ×      |     √      |
|     **动态分区分配** | 装入时基于程序大小动态创建             |     √      |     ×      |
| **动态可重定位分配** | 空间不够时整理分散的小分区为一个大分区 |     √      |     ×      |

#### 动态分区分配算法

需要能描述**空闲分区**和**已分配分区**的数据结构，常用数据结构有**空闲分区表**、**空闲链表**。

若分区回收后与前后分区均为空闲分区，则应将其合并存储。

|              | 思想           | 空闲分区             | 开销 | 大作业 | 特点             |
| -----------: | :------------- | :------------------: | :--: | :--: | :--- |
| **首次适应** | 从头到尾找最适 | 地址递增             |  小  | 有利 | 优先使用低地址 |
| **邻近/循环首次** | 从上次结束开始 | 地址递增 | 小 | 不利 | 高低地址使用均匀 |
| **最佳适应** | 优先使用小分区 | 容量递增             |  大  | 有利 | 许多难以利用小空间 |
| **最坏适应** | 优先使用大分区 | 容量递减             |  大  | 不利 | 产生碎片概率低 |
| **快速适应** | 分区按容量分类 | 分类存放 | 大 | 有利 | 多个空闲分区链表 |

### 分页存储管理

**基本思想**：非连续分配，把进程分页，各个页面离散的放到各个内存块中。

**物理层面**：将内存空间分为多个大小相等（太大可能产生过大的内部碎片）的分区，每个分区就是一个**页框（页帧、内存块、物理块）**，每个页框有一个编号即**页框号（页帧号、内存块号、物理块号）**，页框号从0开始。

**逻辑层面**：用户进程的地址空间也分为与页框大小相等的一个个区域称为**页（页面）**，每个页有一个**页号**，页号从0开始。

#### 页表

**页表**：存储了**逻辑页**与**物理块**的对应关系`(页号, 块号)`。故CPU每次读取数据都需要$2$次访存，第一次访问内存中的页表，第二次通过查询页表获得的物理地址访问内存获得所需数据。

**页表长度**：**页表**有几个**页表项**（多少行）。

**页表项长度**：**页表项**占存储空间大小（一行大小）。

**页面长度**：**页面**占存储空间大小。

**快表**：当页表项缓存于寄存器时，即为快表。此时每次读取数据仅需$1$次访存。

**多级页表**：各级页表大小不能超过一个页面大小，使用两级页表（`(一级页号, 二级页号, 页内偏移量)`、`(页号, 块号)`）需要$3$次访存，$N$级页表需要$N+1$次访存。

#### 地址转换

- $\textnormal{\footnotesize 逻辑地址} = \textnormal{\footnotesize 页号} × \textnormal{\footnotesize 页面长度} + \textnormal{\footnotesize 页面偏移量}$
  - $\textnormal{\footnotesize 页号} = \left\lfloor{\dfrac{\textnormal{\footnotesize 逻辑地址}}{\textnormal{\footnotesize 页面长度}}}\right\rfloor$，并检查页号是否合法
  - $\textnormal{\footnotesize 页内偏移量} = \textnormal{\footnotesize 逻辑地址} {\rm \ mod \ } \textnormal{\footnotesize 页面长度}$
- 查询页表：$\textnormal{\footnotesize 页号} \xrightarrow[]{(\textnormal{\footnotesize 页号}, \textnormal{\footnotesize 块号})} \textnormal{\footnotesize 块号}$
- $\textnormal{\footnotesize 起始地址} = \textnormal{\footnotesize 块号} × \textnormal{\footnotesize 块大小}$
- $\textnormal{\footnotesize 物理地址} = \textnormal{\footnotesize 起始地址} + \textnormal{\footnotesize 页内偏移量}$

**例**：页面长度=`1KB = 0x400`，页表如下，问逻辑地址`0A1F(H)`对应的物理地址

| 页号 | 块号 |
| ---: | :--- |
|    0 | 1    |
|    1 | 5    |
|    2 | 3    |
|    3 | 7    |
|    4 | 2    |

- `0x0A1F = 2 × 0x400 + 0x21F`，即页号为`2`（块号为`3`），页面偏移量为`0x21F`。
- 物理地址为`3 × 0x400 + 0x21F = 0xE1F`

### 分段存储管理

|            | 分段                 | 分页                       |
| ---------: | :------------------- | :------------------------- |
|   信息单位 | 信息的物理单位       | 信息的逻辑单位             |
|       目的 | 提高内存利用率       | 更好地满足用户需要         |
| 用户可见性 | 不可见               | 可见                       |
|       大小 | 由系统决定的固定大小 | 取决于用户编译时信息的性质 |
|       维度 | 一维（逻辑地址）     | 二维（段名，段内地址）     |

**段表**：存储了**逻辑段**与**物理地址**的对应关系`(段号（隐含）, 段长, 基址)`。

### 段页式存储管理

先将程序分为若干段，再将每段分为若干页。逻辑地址结构为用户提供`(段号, 段内地址)`，实际存储`(段号, 页号, 页内偏移量)`。段页式段表为`(段号（隐含）, 页表长度, 页表存放地址)`与分段存储管理中的段表不同。段页式访问一个逻辑地址需要访存$3$次（段表`->`页表`->`物理地址），若快表命中则仅需$1$次访存。

### 虚拟内存

从逻辑上扩充内存容量，程序不需要全部装入内存即可允许，运行时根据需要动态调入数据，内存不够时换出一部分数据。

**虚拟内存的最大容量**：由系统的地址结构和外存空间大小决定。

**虚拟内存组成**：主存、辅存、管理单元、管理软件。

**局部性原理**：时间局部性（执行过的指令可能再次执行，访问过的数据可能再次被访问）、空间局部性（访问过的存储单元其附件的单元也可能被访问）

**虚拟内存特征**：多次性（一个作业分成多次调入内存）、对换性（将暂时不使用的进程调出到外存）、虚拟性（逻辑上扩充内存容量）

**调入策略**：预调页策略、请求调页策略

#### 实现技术

- 虚拟内存实现
  - 请求分页存储管理
    - 页表有所改变为`(页号, 块号, 状态位, 访问字段, 修改位, 外存地址)`
    - 缺页中断为内中断中的故障，属于可以被系统修复的异常
    - 一条执行在执行过程中可能产生多次缺页中断
  - 请求分段存储管理
  - 请求段页式存储管理
- 请求调页功能：访问信息不存在时
- 页面置换功能：内存空间不够时

#### 页面置换算法

|                           | 优先淘汰               | 性能 | 特点                         |
| ------------------------: | :--------------------- | :--: | :--------------------------- |
|   **最佳置换算法（OPT）** | 最长时间不被访问的页面 | 最好 | 缺页率最小，但无法实现       |
|      **先进先出（FIFO）** | 最先进入内存的页面     | 很差 | 实现简单，可能出现Belady异常 |
| **最近最久未使用（LRU）** | 最近最久没有访问的页面 |  好  | 算法开销大，需硬件支持       |
|             **CLOCK/NRU** | 第一个访问位为0的      |  好  | 实现简单，开销小             |
|           最少使用（LFU） |                        |      |                              |
|           页面缓冲（PBA） |                        |      |                              |

**CLOCK/NRU算法**：采用循环队列构建页面队列，记录`(访问位)`，访问后若为1则置为0，最多2轮即可找到要淘汰的页。

**改进的CLOCK/NRU算法**：增加了置换代价因素，记录`(访问位, 修改位)`，最多进行4轮扫描即可找到要淘汰的页。

- 第1轮：扫描替换第一个`(0,0)`
- 第1轮：扫描替换第一个`(0,1)`，所有扫描过的`访问位=0`
- 第3轮：扫描替换第一个`(0,0)`
- 第4轮：扫描替换第一个`(0,1)`

#### 页面分配策略

**驻留集**：请求分页存储管理中给进程分配的物理块的集合。

**工作集**：某段时间间隔内，进程实际访问的页面的集合。

**固定分配/可变分配**：运行期间驻留集大小是否可变。

**局部替换/全局替换**：缺页时，是否只能换出进程自己的页面。

**抖动**：刚换入的页面马上又要换出，主要原因是进程频繁访问的页面数目高于可用物理块数，即分配给进程的物理块不够。

- 固定分配局部替换
- 可变分配全局替换：发生缺页就会获得新物理块；内存耗尽时，选择一个未锁定页面调出，该页所属进程缺页率会增加。
- 可变分配局部替换：频繁缺页则适当增加物理块；反之则适当减少物理块。
